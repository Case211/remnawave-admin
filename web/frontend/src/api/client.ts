import axios, { AxiosError, InternalAxiosRequestConfig } from 'axios'
import { getAuthState } from '../store/authBridge'

/**
 * Get the API base URL.
 * If API_URL is empty, use relative path (recommended for same-domain nginx proxy).
 * If API_URL is set to http:// but page is on https://, auto-upgrade to https://
 * to prevent Mixed Content browser errors.
 *
 * Config is loaded at runtime from window.__ENV (generated by docker-entrypoint.sh),
 * with fallback to Vite's import.meta.env for local development.
 */
function getApiBaseUrl(): string {
  const envUrl = window.__ENV?.API_URL || import.meta.env.VITE_API_URL || ''
  if (!envUrl) return '/api/v2'

  // Auto-fix Mixed Content: upgrade http:// to https:// if page is served over HTTPS
  if (
    typeof window !== 'undefined' &&
    window.location.protocol === 'https:' &&
    envUrl.startsWith('http://')
  ) {
    return envUrl.replace('http://', 'https://') + '/api/v2'
  }

  return `${envUrl}/api/v2`
}

/**
 * Axios client with interceptors for auth
 */
const client = axios.create({
  baseURL: getApiBaseUrl(),
  headers: {
    'Content-Type': 'application/json',
  },
  timeout: 30000,
})

/**
 * Request interceptor - add auth token from Zustand store (in-memory).
 * Reading from the store directly is more reliable than localStorage
 * (avoids timing issues with persist middleware).
 */
client.interceptors.request.use(
  (config: InternalAxiosRequestConfig) => {
    const auth = getAuthState()
    if (auth?.accessToken) {
      config.headers.Authorization = `Bearer ${auth.accessToken}`
    }
    return config
  },
  (error) => Promise.reject(error)
)

/**
 * Refresh token mutex — prevents multiple concurrent 401 responses
 * from each triggering independent refresh requests.
 * Only the first 401 performs the refresh; others wait for the result.
 */
let isRefreshing = false
let refreshPromise: Promise<{ access_token: string; refresh_token: string }> | null = null

function doRefresh(refreshToken: string): Promise<{ access_token: string; refresh_token: string }> {
  if (isRefreshing && refreshPromise) {
    return refreshPromise
  }

  isRefreshing = true
  const promise = axios
    .post(`${getApiBaseUrl()}/auth/refresh`, { refresh_token: refreshToken })
    .then((response) => response.data as { access_token: string; refresh_token: string })
    .finally(() => {
      isRefreshing = false
      refreshPromise = null
    })

  refreshPromise = promise
  return promise
}

/**
 * Force logout — clear auth state and redirect to login page.
 */
function forceLogout() {
  const auth = getAuthState()
  if (auth) {
    auth.logout()
  }
  // Only redirect if not already on the login page
  if (window.location.pathname !== '/login') {
    window.location.href = '/login'
  }
}

/**
 * Response interceptor - handle errors and token refresh
 */
client.interceptors.response.use(
  (response) => response,
  async (error: AxiosError) => {
    const originalRequest = error.config as InternalAxiosRequestConfig & { _retry?: boolean }

    // If 401 and not already retrying, try to refresh token
    if (error.response?.status === 401 && !originalRequest._retry) {
      originalRequest._retry = true

      const auth = getAuthState()

      // No refresh token available — force logout immediately
      if (!auth?.refreshToken) {
        forceLogout()
        return Promise.reject(error)
      }

      try {
        const { access_token, refresh_token } = await doRefresh(auth.refreshToken)

        // Update tokens in Zustand store (will also persist to localStorage)
        auth.setTokens(access_token, refresh_token)

        // Retry original request
        originalRequest.headers.Authorization = `Bearer ${access_token}`
        return client(originalRequest)
      } catch (refreshError) {
        // Refresh failed - force logout
        forceLogout()
        return Promise.reject(refreshError)
      }
    }

    // If already retried and still 401, force logout
    if (error.response?.status === 401 && originalRequest._retry) {
      forceLogout()
    }

    return Promise.reject(error)
  }
)

export default client
